{
    "func_name": "cbs_jpeg_split_fragment",
    "func_src_before": "static int cbs_jpeg_split_fragment(CodedBitstreamContext *ctx,\n                                   CodedBitstreamFragment *frag,\n                                   int header)\n{\n    AVBufferRef *data_ref;\n    uint8_t *data;\n    size_t data_size;\n    int unit, start, end, marker, next_start, next_marker;\n    int err, i, j, length;\n\n    if (frag->data_size < 4) {\n        // Definitely too short to be meaningful.\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i + 1 < frag->data_size && frag->data[i] != 0xff; i++);\n    if (i > 0) {\n        av_log(ctx->log_ctx, AV_LOG_WARNING, \"Discarding %d bytes at \"\n               \"beginning of image.\\n\", i);\n    }\n    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n    if (i + 1 >= frag->data_size && frag->data[i]) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n               \"no SOI marker found.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    marker = frag->data[i];\n    if (marker != JPEG_MARKER_SOI) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: first \"\n               \"marker is %02x, should be SOI.\\n\", marker);\n        return AVERROR_INVALIDDATA;\n    }\n    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n    if (i + 1 >= frag->data_size) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n               \"no image content found.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    marker = frag->data[i];\n    start  = i + 1;\n\n    for (unit = 0;; unit++) {\n        if (marker == JPEG_MARKER_EOI) {\n            break;\n        } else if (marker == JPEG_MARKER_SOS) {\n            for (i = start; i + 1 < frag->data_size; i++) {\n                if (frag->data[i] != 0xff)\n                    continue;\n                end = i;\n                for (++i; i + 1 < frag->data_size &&\n                          frag->data[i] == 0xff; i++);\n                if (i + 1 >= frag->data_size) {\n                    next_marker = -1;\n                } else {\n                    if (frag->data[i] == 0x00)\n                        continue;\n                    next_marker = frag->data[i];\n                    next_start  = i + 1;\n                }\n                break;\n            }\n        } else {\n            i = start;\n            if (i + 2 > frag->data_size) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                       \"truncated at %02x marker.\\n\", marker);\n                return AVERROR_INVALIDDATA;\n            }\n            length = AV_RB16(frag->data + i);\n            if (i + length > frag->data_size) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                       \"truncated at %02x marker segment.\\n\", marker);\n                return AVERROR_INVALIDDATA;\n            }\n            end = start + length;\n\n            i = end;\n            if (frag->data[i] != 0xff) {\n                next_marker = -1;\n            } else {\n                for (++i; i + 1 < frag->data_size &&\n                          frag->data[i] == 0xff; i++);\n                if (i + 1 >= frag->data_size) {\n                    next_marker = -1;\n                } else {\n                    next_marker = frag->data[i];\n                    next_start  = i + 1;\n                }\n            }\n        }\n\n        if (marker == JPEG_MARKER_SOS) {\n            length = AV_RB16(frag->data + start);\n\n            data_ref = NULL;\n            data     = av_malloc(end - start +\n                                 AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!data)\n                return AVERROR(ENOMEM);\n\n            memcpy(data, frag->data + start, length);\n            for (i = start + length, j = length; i < end; i++, j++) {\n                if (frag->data[i] == 0xff) {\n                    while (frag->data[i] == 0xff)\n                        ++i;\n                    data[j] = 0xff;\n                } else {\n                    data[j] = frag->data[i];\n                }\n            }\n            data_size = j;\n\n            memset(data + data_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n        } else {\n            data      = frag->data + start;\n            data_size = end - start;\n            data_ref  = frag->data_ref;\n        }\n\n        err = ff_cbs_insert_unit_data(ctx, frag, unit, marker,\n                                      data, data_size, data_ref);\n        if (err < 0)\n            return err;\n\n        if (next_marker == -1)\n            break;\n        marker = next_marker;\n        start  = next_start;\n    }\n\n    return 0;\n}",
    "func_src_after": "static int cbs_jpeg_split_fragment(CodedBitstreamContext *ctx,\n                                   CodedBitstreamFragment *frag,\n                                   int header)\n{\n    AVBufferRef *data_ref;\n    uint8_t *data;\n    size_t data_size;\n    int unit, start, end, marker, next_start, next_marker;\n    int err, i, j, length;\n\n    if (frag->data_size < 4) {\n        // Definitely too short to be meaningful.\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i + 1 < frag->data_size && frag->data[i] != 0xff; i++);\n    if (i > 0) {\n        av_log(ctx->log_ctx, AV_LOG_WARNING, \"Discarding %d bytes at \"\n               \"beginning of image.\\n\", i);\n    }\n    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n    if (i + 1 >= frag->data_size && frag->data[i]) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n               \"no SOI marker found.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    marker = frag->data[i];\n    if (marker != JPEG_MARKER_SOI) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: first \"\n               \"marker is %02x, should be SOI.\\n\", marker);\n        return AVERROR_INVALIDDATA;\n    }\n    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n    if (i + 1 >= frag->data_size) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n               \"no image content found.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    marker = frag->data[i];\n    start  = i + 1;\n\n    for (unit = 0;; unit++) {\n        if (marker == JPEG_MARKER_EOI) {\n            break;\n        } else if (marker == JPEG_MARKER_SOS) {\n            for (i = start; i + 1 < frag->data_size; i++) {\n                if (frag->data[i] != 0xff)\n                    continue;\n                end = i;\n                for (++i; i + 1 < frag->data_size &&\n                          frag->data[i] == 0xff; i++);\n                if (i + 1 >= frag->data_size) {\n                    next_marker = -1;\n                } else {\n                    if (frag->data[i] == 0x00)\n                        continue;\n                    next_marker = frag->data[i];\n                    next_start  = i + 1;\n                }\n                break;\n            }\n        } else {\n            i = start;\n            if (i + 2 > frag->data_size) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                       \"truncated at %02x marker.\\n\", marker);\n                return AVERROR_INVALIDDATA;\n            }\n            length = AV_RB16(frag->data + i);\n            if (i + length > frag->data_size) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                       \"truncated at %02x marker segment.\\n\", marker);\n                return AVERROR_INVALIDDATA;\n            }\n            end = start + length;\n\n            i = end;\n            if (frag->data[i] != 0xff) {\n                next_marker = -1;\n            } else {\n                for (++i; i + 1 < frag->data_size &&\n                          frag->data[i] == 0xff; i++);\n                if (i + 1 >= frag->data_size) {\n                    next_marker = -1;\n                } else {\n                    next_marker = frag->data[i];\n                    next_start  = i + 1;\n                }\n            }\n        }\n\n        if (marker == JPEG_MARKER_SOS) {\n            length = AV_RB16(frag->data + start);\n\n            if (length > end - start)\n                return AVERROR_INVALIDDATA;\n\n            data_ref = NULL;\n            data     = av_malloc(end - start +\n                                 AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!data)\n                return AVERROR(ENOMEM);\n\n            memcpy(data, frag->data + start, length);\n            for (i = start + length, j = length; i < end; i++, j++) {\n                if (frag->data[i] == 0xff) {\n                    while (frag->data[i] == 0xff)\n                        ++i;\n                    data[j] = 0xff;\n                } else {\n                    data[j] = frag->data[i];\n                }\n            }\n            data_size = j;\n\n            memset(data + data_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n        } else {\n            data      = frag->data + start;\n            data_size = end - start;\n            data_ref  = frag->data_ref;\n        }\n\n        err = ff_cbs_insert_unit_data(ctx, frag, unit, marker,\n                                      data, data_size, data_ref);\n        if (err < 0)\n            return err;\n\n        if (next_marker == -1)\n            break;\n        marker = next_marker;\n        start  = next_start;\n    }\n\n    return 0;\n}",
    "line_changes": {
        "deleted": [],
        "added": [
            {
                "line_no": 95,
                "char_start": 3398,
                "char_end": 3436,
                "line": "            if (length > end - start)\n"
            },
            {
                "line_no": 96,
                "char_start": 3436,
                "char_end": 3480,
                "line": "                return AVERROR_INVALIDDATA;\n"
            },
            {
                "line_no": 97,
                "char_start": 3480,
                "char_end": 3481,
                "line": "\n"
            }
        ]
    },
    "char_changes": {
        "deleted": [],
        "added": [
            {
                "char_start": 3410,
                "char_end": 3493,
                "chars": "if (length > end - start)\n                return AVERROR_INVALIDDATA;\n\n            "
            }
        ]
    },
    "commit_link": "github.com/FFmpeg/FFmpeg/commit/1812352d767ccf5431aa440123e2e260a4db2726",
    "file_name": "libavcodec/cbs_jpeg.c",
    "vul_type": "cwe-787"
}
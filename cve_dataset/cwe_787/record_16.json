{
    "func_name": "tcp_test",
    "func_src_before": "int tcp_test(const char* ip_str, const short port)\n{\n    int sock, i;\n    struct sockaddr_in s_in;\n    int packetsize = 1024;\n    unsigned char packet[packetsize];\n    struct timeval tv, tv2, tv3;\n    int caplen = 0;\n    int times[REQUESTS];\n    int min, avg, max, len;\n    struct net_hdr nh;\n\n    tv3.tv_sec=0;\n    tv3.tv_usec=1;\n\n    s_in.sin_family = PF_INET;\n    s_in.sin_port = htons(port);\n    if (!inet_aton(ip_str, &s_in.sin_addr))\n            return -1;\n\n    if ((sock = socket(s_in.sin_family, SOCK_STREAM, IPPROTO_TCP)) == -1)\n            return -1;\n\n    /* avoid blocking on reading the socket */\n    if( fcntl( sock, F_SETFL, O_NONBLOCK ) < 0 )\n    {\n        perror( \"fcntl(O_NONBLOCK) failed\" );\n        return( 1 );\n    }\n\n    gettimeofday( &tv, NULL );\n\n    while (1)  //waiting for relayed packet\n    {\n        if (connect(sock, (struct sockaddr*) &s_in, sizeof(s_in)) == -1)\n        {\n            if(errno != EINPROGRESS && errno != EALREADY)\n            {\n                perror(\"connect\");\n                close(sock);\n\n                printf(\"Failed to connect\\n\");\n\n                return -1;\n            }\n        }\n        else\n        {\n            gettimeofday( &tv2, NULL );\n            break;\n        }\n\n        gettimeofday( &tv2, NULL );\n        //wait 3000ms for a successful connect\n        if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (3000*1000))\n        {\n            printf(\"Connection timed out\\n\");\n            close(sock);\n            return(-1);\n        }\n        usleep(10);\n    }\n\n    PCT; printf(\"TCP connection successful\\n\");\n\n    //trying to identify airserv-ng\n    memset(&nh, 0, sizeof(nh));\n//     command: GET_CHAN\n    nh.nh_type\t= 2;\n    nh.nh_len\t= htonl(0);\n\n    if (send(sock, &nh, sizeof(nh), 0) != sizeof(nh))\n    {\n        perror(\"send\");\n        return -1;\n    }\n\n    gettimeofday( &tv, NULL );\n    i=0;\n\n    while (1)  //waiting for GET_CHAN answer\n    {\n        caplen = read(sock, &nh, sizeof(nh));\n\n        if(caplen == -1)\n        {\n            if( errno != EAGAIN )\n            {\n                perror(\"read\");\n                return -1;\n            }\n        }\n\n        if( (unsigned)caplen == sizeof(nh))\n        {\n            len = ntohl(nh.nh_len);\n            if( nh.nh_type == 1 && i==0 )\n            {\n                i=1;\n                caplen = read(sock, packet, len);\n                if(caplen == len)\n                {\n                    i=2;\n                    break;\n                }\n                else\n                {\n                    i=0;\n                }\n            }\n            else\n            {\n                caplen = read(sock, packet, len);\n            }\n        }\n\n        gettimeofday( &tv2, NULL );\n        //wait 1000ms for an answer\n        if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (1000*1000))\n        {\n            break;\n        }\n        if(caplen == -1)\n            usleep(10);\n    }\n\n    if(i==2)\n    {\n        PCT; printf(\"airserv-ng found\\n\");\n    }\n    else\n    {\n        PCT; printf(\"airserv-ng NOT found\\n\");\n    }\n\n    close(sock);\n\n    for(i=0; i<REQUESTS; i++)\n    {\n        if ((sock = socket(s_in.sin_family, SOCK_STREAM, IPPROTO_TCP)) == -1)\n                return -1;\n\n        /* avoid blocking on reading the socket */\n        if( fcntl( sock, F_SETFL, O_NONBLOCK ) < 0 )\n        {\n            perror( \"fcntl(O_NONBLOCK) failed\" );\n            return( 1 );\n        }\n\n        usleep(1000);\n\n        gettimeofday( &tv, NULL );\n\n        while (1)  //waiting for relayed packet\n        {\n            if (connect(sock, (struct sockaddr*) &s_in, sizeof(s_in)) == -1)\n            {\n                if(errno != EINPROGRESS && errno != EALREADY)\n                {\n                    perror(\"connect\");\n                    close(sock);\n\n                    printf(\"Failed to connect\\n\");\n\n                    return -1;\n                }\n            }\n            else\n            {\n                gettimeofday( &tv2, NULL );\n                break;\n            }\n\n            gettimeofday( &tv2, NULL );\n            //wait 1000ms for a successful connect\n            if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (1000*1000))\n            {\n                break;\n            }\n            //simple \"high-precision\" usleep\n            select(1, NULL, NULL, NULL, &tv3);\n        }\n        times[i] = ((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec));\n        printf( \"\\r%d/%d\\r\", i, REQUESTS);\n        fflush(stdout);\n        close(sock);\n    }\n\n    min = INT_MAX;\n    avg = 0;\n    max = 0;\n\n    for(i=0; i<REQUESTS; i++)\n    {\n        if(times[i] < min) min = times[i];\n        if(times[i] > max) max = times[i];\n        avg += times[i];\n    }\n    avg /= REQUESTS;\n\n    PCT; printf(\"ping %s:%d (min/avg/max): %.3fms/%.3fms/%.3fms\\n\", ip_str, port, min/1000.0, avg/1000.0, max/1000.0);\n\n    return 0;\n}",
    "func_src_after": "int tcp_test(const char* ip_str, const short port)\n{\n    int sock, i;\n    struct sockaddr_in s_in;\n    int packetsize = 1024;\n    unsigned char packet[packetsize];\n    struct timeval tv, tv2, tv3;\n    int caplen = 0;\n    int times[REQUESTS];\n    int min, avg, max, len;\n    struct net_hdr nh;\n\n    tv3.tv_sec=0;\n    tv3.tv_usec=1;\n\n    s_in.sin_family = PF_INET;\n    s_in.sin_port = htons(port);\n    if (!inet_aton(ip_str, &s_in.sin_addr))\n            return -1;\n\n    if ((sock = socket(s_in.sin_family, SOCK_STREAM, IPPROTO_TCP)) == -1)\n            return -1;\n\n    /* avoid blocking on reading the socket */\n    if( fcntl( sock, F_SETFL, O_NONBLOCK ) < 0 )\n    {\n        perror( \"fcntl(O_NONBLOCK) failed\" );\n        return( 1 );\n    }\n\n    gettimeofday( &tv, NULL );\n\n    while (1)  //waiting for relayed packet\n    {\n        if (connect(sock, (struct sockaddr*) &s_in, sizeof(s_in)) == -1)\n        {\n            if(errno != EINPROGRESS && errno != EALREADY)\n            {\n                perror(\"connect\");\n                close(sock);\n\n                printf(\"Failed to connect\\n\");\n\n                return -1;\n            }\n        }\n        else\n        {\n            gettimeofday( &tv2, NULL );\n            break;\n        }\n\n        gettimeofday( &tv2, NULL );\n        //wait 3000ms for a successful connect\n        if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (3000*1000))\n        {\n            printf(\"Connection timed out\\n\");\n            close(sock);\n            return(-1);\n        }\n        usleep(10);\n    }\n\n    PCT; printf(\"TCP connection successful\\n\");\n\n    //trying to identify airserv-ng\n    memset(&nh, 0, sizeof(nh));\n//     command: GET_CHAN\n    nh.nh_type\t= 2;\n    nh.nh_len\t= htonl(0);\n\n    if (send(sock, &nh, sizeof(nh), 0) != sizeof(nh))\n    {\n        perror(\"send\");\n        return -1;\n    }\n\n    gettimeofday( &tv, NULL );\n    i=0;\n\n    while (1)  //waiting for GET_CHAN answer\n    {\n        caplen = read(sock, &nh, sizeof(nh));\n\n        if(caplen == -1)\n        {\n            if( errno != EAGAIN )\n            {\n                perror(\"read\");\n                return -1;\n            }\n        }\n\n        if( (unsigned)caplen == sizeof(nh))\n        {\n            len = ntohl(nh.nh_len);\n            if (len > 1024 || len < 0)\n                continue;\n            if( nh.nh_type == 1 && i==0 )\n            {\n                i=1;\n                caplen = read(sock, packet, len);\n                if(caplen == len)\n                {\n                    i=2;\n                    break;\n                }\n                else\n                {\n                    i=0;\n                }\n            }\n            else\n            {\n                caplen = read(sock, packet, len);\n            }\n        }\n\n        gettimeofday( &tv2, NULL );\n        //wait 1000ms for an answer\n        if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (1000*1000))\n        {\n            break;\n        }\n        if(caplen == -1)\n            usleep(10);\n    }\n\n    if(i==2)\n    {\n        PCT; printf(\"airserv-ng found\\n\");\n    }\n    else\n    {\n        PCT; printf(\"airserv-ng NOT found\\n\");\n    }\n\n    close(sock);\n\n    for(i=0; i<REQUESTS; i++)\n    {\n        if ((sock = socket(s_in.sin_family, SOCK_STREAM, IPPROTO_TCP)) == -1)\n                return -1;\n\n        /* avoid blocking on reading the socket */\n        if( fcntl( sock, F_SETFL, O_NONBLOCK ) < 0 )\n        {\n            perror( \"fcntl(O_NONBLOCK) failed\" );\n            return( 1 );\n        }\n\n        usleep(1000);\n\n        gettimeofday( &tv, NULL );\n\n        while (1)  //waiting for relayed packet\n        {\n            if (connect(sock, (struct sockaddr*) &s_in, sizeof(s_in)) == -1)\n            {\n                if(errno != EINPROGRESS && errno != EALREADY)\n                {\n                    perror(\"connect\");\n                    close(sock);\n\n                    printf(\"Failed to connect\\n\");\n\n                    return -1;\n                }\n            }\n            else\n            {\n                gettimeofday( &tv2, NULL );\n                break;\n            }\n\n            gettimeofday( &tv2, NULL );\n            //wait 1000ms for a successful connect\n            if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (1000*1000))\n            {\n                break;\n            }\n            //simple \"high-precision\" usleep\n            select(1, NULL, NULL, NULL, &tv3);\n        }\n        times[i] = ((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec));\n        printf( \"\\r%d/%d\\r\", i, REQUESTS);\n        fflush(stdout);\n        close(sock);\n    }\n\n    min = INT_MAX;\n    avg = 0;\n    max = 0;\n\n    for(i=0; i<REQUESTS; i++)\n    {\n        if(times[i] < min) min = times[i];\n        if(times[i] > max) max = times[i];\n        avg += times[i];\n    }\n    avg /= REQUESTS;\n\n    PCT; printf(\"ping %s:%d (min/avg/max): %.3fms/%.3fms/%.3fms\\n\", ip_str, port, min/1000.0, avg/1000.0, max/1000.0);\n\n    return 0;\n}",
    "line_changes": {
        "deleted": [],
        "added": [
            {
                "line_no": 97,
                "char_start": 2251,
                "char_end": 2290,
                "line": "            if (len > 1024 || len < 0)\n"
            },
            {
                "line_no": 98,
                "char_start": 2290,
                "char_end": 2316,
                "line": "                continue;\n"
            }
        ]
    },
    "char_changes": {
        "deleted": [],
        "added": [
            {
                "char_start": 2265,
                "char_end": 2330,
                "chars": " (len > 1024 || len < 0)\n                continue;\n            if"
            }
        ]
    },
    "commit_link": "github.com/aircrack-ng/aircrack-ng/commit/091b153f294b9b695b0b2831e65936438b550d7b",
    "file_name": "src/aireplay-ng.c",
    "vul_type": "cwe-787"
}